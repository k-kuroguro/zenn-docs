---
title: "[Python] コンソールでのキーボードイベントをハンドルする"
emoji: "⌨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["cli", "keyboard", "python", "python3"]
published: false
---

# 概要

Python 実装の CLI アプリケーションにおいて, キーボードイベント (キー押下イベント) をハンドルする方法についてまとめる. キー入力の処理は OS 依存だが, 本記事では Windows のみ考える.

なお, 実装については TUI フレームワークの [Textual](https://github.com/Textualize/textual) を参考にした. ソースの一部はここから複製・改変されているため, 注記のあるものには以下のライセンスが適用される.

:::details LICENSE
Copyright (c) 2021 Riku Kanayama (k_kuroguro)
Released under the MIT license
https://github.com/k-kuroguro/zenn-docs/blob/master/MIT_LICENSE

The original copyright notice for Will McGugan:

Copyright (c) 2021 Will McGugan
Released under the MIT license
https://github.com/Textualize/textual/blob/main/LICENSE
:::

# 環境

 - Windows 11
 - Python 3.9.7

# 構成

## 大まかな流れ

1. keyboard モジュールが Keys クラス(列挙体)と on_press 関数を提供する.
2. 呼び出し側は, 引数に対象のキー (文字列または Keys 列挙体) とハンドラを渡して, on_press 関数を実行する.
3. 対象のキー押下イベントが発生すると, ハンドラが起動される.

```python
from keyboard import Keys, on_press

def on_press_a() -> None:
   print('Pressed "a"')

def on_press_ctrl_c() => None:
   print('Pressed "Ctrl+C"')

on_press('a', on_press_a)
on_press(Keys.CTRL_C, on_press_ctrl_c)
```

## ファイル構成

モジュールのファイル構成を以下に示す.

```
keyboard
   ├─ event.py
   ├─ keys.py
   ├─ _ansi_sequences.py
   ├─ _listener.py
   ├─ _parser.py
   ├─ _windows.py
   └─ __init__.py
```

それぞれの責務は

- event
  KeyEvent クラスを定義する.
- keys
  特殊キー (e.g. `ctrl+c`, `esc`) を表す Keys 列挙体を定義する.
  (なお, それ以外の文字・数字・記号キーは, 文字列 (e.g. `'a'`, `'1'`) で対応する.)
- _ansi_sequences
  ANSI エスケープシーケンスと Keys 列挙体の対応表を持つ.
- _listener
  それぞれキー入力の読取とイベントハンドラの起動を行う2つのスレッドを管理する.
- _parser.
  string 型のキー入力のうち, 特殊キーを Keys 列挙体に変換する.
- _windows
  Windows 依存のキー入力処理を行う.
- \_\_init__
  ユーザがハンドルの追加を行える on_press 関数を提供する.

となっている.

# キー入力の処理

本プログラムで必要なキー入力に関する OS 依存の処理は, 以下の2つである.

- 仮想ターミナルシーケンスの有効化．
- コンソールからの入力読取.

どちらも Windows のコンソール API を使用する. 各定数・構造体・関数の詳細は [Microsoft Docs](https://learn.microsoft.com/en-us/windows/console/console-reference) を参照のこと.

## 仮想ターミナルシーケンスの有効化

仮想ターミナルシーケンス (ANSI エスケープシーケンス) は, 多くのプラットフォームでサポートされているコンソール制御の標準である. 有効化すれば, 入力がこのシーケンスに変換されるため, 使用しているターミナルの種類を問わずに特殊キーを処理できるようになる.

シーケンスの有効化は, SetConsoleMode 関数で行う. この関数はコンソールの設定を書き換えるため, GetConsoleMode 関数で元の設定を取得し, 保存しておく必要がある.

```python
import msvcrt
import sys
from ctypes import WinDLL, byref
from ctypes.wintypes import DWORD
from typing import IO, Any, Callable

# Adapted from Textual.
# See above LICENSE.

_ENABLE_VIRTUAL_TERMINAL_INPUT = 0x0200

_kernel32 = WinDLL('kernel32', use_last_error=True)

_SetConsoleMode = _kernel32.SetConsoleMode
_GetConsoleMode = _kernel32.GetConsoleMode

def _set_console_mode(file: IO[Any], mode: int) -> bool:
    '''Set the console mode for a given file (stdout or stdin).'''

    windows_filehandle = msvcrt.get_osfhandle(file.fileno())
    success: bool = _SetConsoleMode(windows_filehandle, mode)
    return success

def _get_console_mode(file: IO[Any]) -> int:
    '''Get the console mode for a given file (stdout or stdin).'''

    windows_filehandle = msvcrt.get_osfhandle(file.fileno())
    mode = DWORD()
    _GetConsoleMode(windows_filehandle, byref(mode))
    return mode.value

def enable_virtual_terminal_sequences() -> Callable[[], None]:
    '''Enable virtual terminal sequences.'''

    terminal_in = sys.stdin
    terminal_out = sys.stdout

    current_console_mode_in = _get_console_mode(terminal_in)
    current_console_mode_out = _get_console_mode(terminal_out)

    def restore() -> None:
        '''Restore console mode to previous settings.'''

        _set_console_mode(terminal_in, current_console_mode_in)
        _set_console_mode(terminal_out, current_console_mode_out)

    _set_console_mode(terminal_in, current_console_mode_in | _ENABLE_VIRTUAL_TERMINAL_INPUT)
    return restore
```

## コンソールからの入力読取

コンソールからの入力は, ReadConsoleInput 関数で読み取れる. このとき, 標準入力がシグナル状態になるまで待機するために, WaitForMultipleObjects 関数を利用した.

```python
from ctypes import Structure, Union, WinDLL, byref
from ctypes.wintypes import BOOL, CHAR, DWORD, HANDLE, SHORT, UINT, WCHAR, WORD
from typing import Callable, Optional

# Adapted from Textual.
# See above LICENSE.

class COORD(Structure):
    _fields_ = [
        ('X', SHORT),
        ('Y', SHORT)
    ]

class uChar(Union):
    _fields_ = [
        ('UnicodeChar', WCHAR),
        ('AsciiChar', CHAR)
    ]

class KEY_EVENT_RECORD(Structure):
    _fields_ = [
        ('bKeyDown', BOOL),
        ('wRepeatCount', WORD),
        ('wVirtualKeyCode', WORD),
        ('wVirtualScanCode', WORD),
        ('uChar', uChar),
        ('dwControlKeyState', DWORD)
    ]

class MOUSE_EVENT_RECORD(Structure):
    _fields_ = [
        ('dwMousePosition', COORD),
        ('dwButtonState', DWORD),
        ('dwControlKeyState', DWORD),
        ('dwEventFlags', DWORD)
    ]

class WINDOW_BUFFER_SIZE_RECORD(Structure):
    _fields_ = [
        ('dwSize', COORD)
    ]

class MENU_EVENT_RECORD(Structure):
    _fields_ = [
        ('dwCommandId', UINT)
    ]

class FOCUS_EVENT_RECORD(Structure):
    _fields_ = [
        ('bSetFocus', BOOL)
    ]

class InputEvent(Union):
    _fields_ = [
        ('KeyEvent', KEY_EVENT_RECORD),
        ('MouseEvent', MOUSE_EVENT_RECORD),
        ('WindowBufferSizeEvent', WINDOW_BUFFER_SIZE_RECORD),
        ('MenuEvent', MENU_EVENT_RECORD),
        ('FocusEvent', FOCUS_EVENT_RECORD)
    ]

class INPUT_RECORD(Structure):
    _fields_ = [
        ('EventType', WORD),
        ('Event', InputEvent)
    ]

_WAIT_TIMEOUT = 0x00000102

_MAX_EVENTS = 1024
_KEY_EVENT = 0x0001

_kernel32 = WinDLL('kernel32', use_last_error=True)

_GetStdHandle = _kernel32.GetStdHandle
_GetStdHandle.argtypes = [DWORD]
_GetStdHandle.restype = HANDLE
_ReadConsoleInputW = _kernel32.ReadConsoleInputW
_WaitForMultipleObjects = _kernel32.WaitForMultipleObjects

_hIn = _GetStdHandle(_STD_INPUT_HANDLE)
_arrtype = INPUT_RECORD * _MAX_EVENTS
_input_records = _arrtype()
_read_count = DWORD(0)

def _wait_for_handles(handles: list[HANDLE], timeout: int = 0) -> Optional[HANDLE]:
    arrtype = HANDLE * len(handles)
    handle_array = arrtype(*handles)

    ret: int = _WaitForMultipleObjects(
        len(handle_array), handle_array, BOOL(False), DWORD(timeout)
    )

    if ret == _WAIT_TIMEOUT:
        return None
    else:
        return handles[ret]

def listen(on_press: Callable[[list[str]], None]) -> None:
    '''Listen key press events. '''

    if _wait_for_handles([_hIn], 200) is None:
        return

    _ReadConsoleInputW(
        _hIn, byref(_input_records), _MAX_EVENTS, byref(_read_count)
    )
    read_input_records = _input_records[:_read_count.value]

    del _keys[:]

    for input_record in read_input_records:
        event_type = input_record.EventType

        if event_type == _KEY_EVENT:
            key_event = input_record.Event.KeyEvent
            key = key_event.uChar.UnicodeChar
            if key_event.bKeyDown or key == '\x1b':
                _keys.append(key)

    handler(_keys[:])
```

キー入力を読み取る listen 関数は handler 引数を持ち, 読取後にこれを実行する. この引数に`queue.put`などを渡すことで, 別スレッドで実行される listen 関数が他スレッドへデータを送ることができるようにしている.

# 
